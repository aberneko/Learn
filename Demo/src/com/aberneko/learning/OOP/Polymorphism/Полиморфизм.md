# _Полиморфизм_ 
**_(в переводе с греческого означает «многообразный»)_** — _это способность принимать разные формы._

> - _В применении к языкам программирования полиморфизм означает способность кода, например одного и того же метода, одинаково работать с объектами разных классов, если они реализуют общий интерфейс или наследуются от общего родителя._

---
# _Пример полиморфизма_
```
public interface MailClient {
    void send(String from, String to, String text); // МЕТОД ОТПРАВКИ СООБЩЕНИЯ 
    void recieve();                                 // МЕТОД ПОЛУЧЕНИЯ 
} 

public class Dove implements MailClient {           // РЕАЛИЗУЕМ ИНТЕРФЕЙС 
    @Override                                       // ПЕРЕОПРЕДЕЛЯЕМ МЕТОДЫ
    public void send(String from, String to, String text) {
        System.out.println("Голубь полетел к " + to + " от " + from + " с письмом: " + text);
    }

    @Override
    public void receive() {
        System.out.println("Голубь вернулся с ответным письмом!");
    }
} 

public class Telegraph implements MailClient {      // РЕАЛИЗУЕМ ИНТЕРФЕЙС 
    @Override                                       // ПЕРЕОПРЕДЕЛЯЕМ МЕТОДЫ
    public void send(String from, String to, String text) {
        System.out.println("Телеграф передал для " + to + " от " + from + " коды букв с посланием: " + text);
    }

    @Override
    public void receive() {
        System.out.println("Телеграф напечатал ответное сообщение.");
    }
} 
                                                    // КЛАСС MAIN
MailClient mailClient; // объявили переменную с типом интерфейса MailClient

if(currentCentury < 20) {
    // присваиваем переменной в качестве значения объект класса Dove
    mailClient = new Dove();
} else {
    // присваиваем переменной в качестве значения объект класса Telegraph
    mailClient = new Telegraph();
}

// конкретный тип объекта не важен, если он реализует 
// интерфейс MailClient, потому что у него есть метод send()
mailClient.send();
```

---
# _Полиморфизм и наследование_

_Полиморфизм в программировании проявляется не только в особенностях работы с интерфейсами, но и в механизме наследования. По аналогии с интерфейсами можно сохранять объект наследника в переменную с родительским типом._

## _Пример_
```
class Rodent {                                        // ОБЩИЕ МЕТОДЫ ДЛЯ КОНКРЕТНЫХ ОБЪЕКТОВ
    public void crunch() {
        System.out.println("Грызун грызёт что угодно.");
    }

    public void sleep() {
        System.out.println("Грызун уснул.");
    }
}

class Capybara extends Rodent {

    @Override
    public void crunch() {
        System.out.println("Капибара любит грызть кукурузу.");
    }

    @Override
    public void sleep() {
        System.out.println("Капибара крепко спит.");
    }

    public void dive() {                               //   РЕАЛИЗУЕТ СВОЙ МЕТОД
        System.out.println("Капибара умеет нырять.");
    }
}

public class Practicum {

    public static void main(String[] args) {
        Rodent rodent = new Capybara();                // В ПЕРЕМЕННУЮ ОБЩЕГО КЛАССА СОХРАНЯЕМ ССЫЛКУ НА ОБЪЕКТ
        rodent.crunch();
        rodent.sleep();
    }

}
```
---
 ### _!_ - _В Java все классы наследуются от класса Object. Поэтому все классы полиморфные._

---
# _Виды полиморфизма_

- _Параметрический полиморфизм_
- _Сабтайпинг. (Полиморфизм подтипов)_ 
- _Ad-hoc полиморфизм, или перегрузка_
- ---

## 1. Сабтайпинг. Полиморфизм подтипов

> _Сабтайпинг позволяет использовать объекты более «специализированного» типа вместо объектов более «общего» типа._

- _Принцип работы заключается в том, что в метод, который ожидает на вход один тип объекта, мы можем передать другой тип, но этот тип должен быть обязательно наследников первоначального входного типа. И второе уточнение, либо суперкласс - подкласс, либо переменная интерфейса - реализация._
- _Если в методе в который мы передали объект - наследник входного типа вызвать метод, то он не будет работать, так как в родительском классе такого метода нет._
### _Пример - суперкласс - подкласс_

```
class Person {                                       // ЯВЛЯЕТСЯ СУПЕРКАЛАССОМ
    private final String name;

    Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

class Teacher extends Person {                       // КЛАСС НАСЛЕДНИК
    Teacher(String name) {
        super(name);
    }
}

class Student extends Person {                      // КЛАСС НАСЛЕДНИК
    Student(String name) {
        super(name);
    }
}


class Practicum {
    public static void main(String[] args) {
    
        // создаём объект типа Teacher и передаём его в метод, ожидающий тип Person
        
        Teacher teacher = new Teacher("Василий Петрович");
        printPersonName(teacher);

        // создаём объект типа Student и передаём его в метод, ожидающий тип Person
        
        Student student = new Student("Мария");
        printPersonName(student);
    }

    // параметр метода printPersonName имеет тип Person
    
    public static void printPersonName(Person person) {
        System.out.println("Меня зовут " + person.getName());
    }
}

```
### _Пример - Интерфейс - класс - реализация_

```
interface Printable {
    void print();
}

class Book implements Printable {
    private final String title;

    public Book(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }

    @Override
    public void print() {
        System.out.println("Книга \"" + title + '"');
    }
}

class Point implements Printable {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override
    public void print() {
        System.out.println("x: " + x + ", y: " + y);
    }
}

public class Practicum {
    public static void main(String[] args) {
        // создаём объект типа Book и передаём его в метод, ожидающий тип Printable
        Book book = new Book("Анна Каренина");
        printThis(book);

        // Создаём объект типа Point и передаём его в метод, ожидающий тип Printable
        Point point = new Point(5, -12);
        printThis(point);
    }

    // параметр метода printThis имеет тип Printable
    public static void printThis(Printable printable) {
        printable.print();
    }
}
```
## 2. Ad-hoc полиморфизм

_В Java ad-hoc полиморфизм реализуется через перегрузку (англ. overloading) методов. Этот механизм позволяет создавать множество реализаций одного и того же метода до тех пор, пока различаются типы, порядок или количество его параметров. При этом тип возвращаемого значения можно как менять, так и оставить одинаковым во всех реализациях._

```
import java.util.ArrayList;
import java.util.Arrays;

class Printer {
    void print(int i) {
        System.out.println("Целое число: " + i);
    }

    void print(double d) {
        System.out.println("Дробное число: " + d);
    }

    void print(String s) {
        System.out.println("Строка: " + s);
    }

    void print(Object o) {
        System.out.println("Объект: " + o);
    }
}

public class Practicum {
    public static void main(String[] args) {
        Printer printer = new Printer();

        printer.print(5);
        printer.print(2.5);
        printer.print("Шла Саша по шоссе");
        printer.print(new ArrayList<>());
    }
}
```

## 2. Параметрический полиморфизм



### _Параметр типа возвращаемого значения_

### _Как использовать параметр типа_

