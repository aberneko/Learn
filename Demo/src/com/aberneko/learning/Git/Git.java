package com.aberneko.learning.Git;

public class Git {
    static void main() {

        // commit f9bd906861422db0f87130e710b64a669af02faf (HEAD -> main, origin/main, origin/HEAD)
        System.out.println(

                """
                f9bd906861422db0f87130e710b64a669af02faf --> хэш - идентификатор комита получается с помощью алгоритма
                SHA - 1. В то время как результат работы HashCode() - это целое число, хэширование в GIT - Символьная 
                строка состоящая из 40 символов. Все хэши и таблицу Git сохраняет в служебные файлы. Они находятся в 
                скрытой папке .git в репозитории проекта
                """

        /*
         commit f9bd906861422db0f87130e710b64a669af02faf (HEAD -> main, origin/main, origin/HEAD)              - ХЭШ
         Author: WorkAberneko <kurumi.06.10.t@gmail.com>                                             - АВТОР КОММИТА
         Date:   Wed Feb 11 15:48:02 2026 +0300                                                       - ДАТА КОММИТА
         Изменения структыры 2.0                                                                - ИНФОРМАЦИЯ КОММИТА
        */

        );



        // Сокращённый лог
        System.out.println(

                """
                Сокращённый лог вызывают командой 'git log' c флагом '--oneline' при этом в терминале,
                появляются только первые несколько символов хэша каждого комита и комментарии к ним.
                """

                /*   Если автоматический не произошёл выход, нажимаешь Q   */

        );



        // HEAD
        System.out.println(

                """
                Один из служебных файлов папки .git который указывает на коммит, который сделан последним.
                (Применяется в качестве параметра вместо прописывания хэша).
                Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD.
                """

                /*

                $ pwd
                $ cd B/JavaAll
                $ cd .git/
                $ cd HEAD              <-- Наш служебный файл
                $ cat Head             <-- Просматриваем содержимое
                ref: refs/heads/main   <-- получаем ссылку на служебный фал
                $ cd refs/heads/main

                --> Получаем хэш последнего коммита

                */

        );



        // Что бы избежать закомитить лишнее или же забыть добавить важный файл в коммит, нужно проверять СТАТУСЫ
        // GIT STATUS
        // Статусы untracked/tracked, staged и modified
        System.out.println(

                """
                Ключевая задача отслеживать изменения в файлах
                Каждый файл помечается статусом:
                
                --> untracked (неотслеживаемый)
                              Git «видит», что такой файл существует, но не следит за изменениями в нём.
                
                --> staged (подготовленный)
                              Состояние файла(staged иногда называют 'indexed' или `cached`) на этапе подготовки к
                              коммиту после команды '--git add'.
                
                --> tracked (отслеживаемый)
                              Файлы который уже зафиксированный с помощью `--git commit` and `--git add`
                
                --> modified (изменённый)
                              Файл который уже был под `--git commit` но в него опять внесли правки
                
                `--git status` показывает только следующие состояние файлов
                    --> staged (Changes to be committed)
                    --> modified (Changes not staged for commit)
                    --> untracked (Untracked files)
                    
                git status --ignored - отображает в выводе 
                """

        );



        // Оформление сообщений к коммитам
        System.out.println(

                """
                `--git log --oneline` максимальная вместимость символов 72
                Писать сообщение с инфинитивом в глаголе
                """

        );



        // Как исправить коммит
        System.out.println(

                """
                `git commit --amend` - внести правки уже в созданный коммит
                
                    `--no-edit` - говорит гиту сохранить сообщение прошлого коммита
                
                Так же стоить отметить что после выполнения данной команды старый коммит и новый смешиваются под новым 
                номером хэша. То есть проще говоря создается новый коммит (объект) а старый удаляется
                
                    '-m " " - для изменения сообщения коммита (Хэш коммита тоже и изменится)
                    
                """
        );



        // Как откатится назад если все сломалось
        System.out.println(

                """
                `--git restore --staged` <file> - убрать файл из добавленных(staged). <.> - убрать всё.
               
                `-git reset --hard <commit>` - откат(удаление) последнего коммита
                
                `--git restore file` - откатывает изменения файла если он находится в статусе modified + 
                                       (на этапе staged and tracked)
                                       
                """

        );



        // Как откатится назад если все сломалось
        System.out.println(

                """
                `--git restore --staged` <file> - убрать файл из добавленных(staged). <.> - убрать всё.
                
                `-git reset --hard <commit>` - откат(удаление) последнего коммита
                
                `--git restore file` - откатывает изменения файла если он находится в статусе modified + 
                                       (на этапе staged and tracked)
                                       
                """

        );



        // git diff - Просматриваем изменения и сопоставляем коммиты
        System.out.println(

                """
                `git diff <log>` - позволяет просмотреть изменения в коммите
                    --- a/pro.txt - до изменения
                    +++ b/pro.txt - после изменения
                
                    красный (-) была удалена
                    зелёный (+) была добавлена
                
                В самом выводе @@ -1,2 +1,9 @@ 
                            
                            с `-` показывает что в старой версии файла этот кусок занимал 2 строки начиная с первой
                            с `+` показывает что в новой версии файла этот кусок занимает 9 строк но всё же начинается с первого файла 
                            
                с приставкой --staged просматриваю изменения на этапе подготовки к коммиту
                """

        );



        // .gitignore
        System.out.println(

                """
                .gitignore - файлы которые мы хотим игнорировать перед выполнением команд `--git add or commit -m`
                Это обычный текстовый файл который добавляют в корень репозитория и тоже комитят
                
                В простейшем случае в него указывают все файлы по одному на строку, но лучше использовать -
                ШАБЛОН - способ указать сразу несколько файлов с однотипным названием
                
                --------------------------------------------------------------------------------------------------------
                
                # - комментарий - он не будет их учитывать
                
                --------------------------------------------------------------------------------------------------------
                
                * (Пример *.txt) - будет игнорировать все фалы с таким расширением
                        docs/*/tmp - будет игнорировать все файлы tmp пропуская 1 уровень папки docs 
                                Если поставить как правило одну лишь * - то git будет игнорировать все файлы
                                
                --------------------------------------------------------------------------------------------------------
                
                ? - если в file?.txt поставить знак вопроса, то будут проигнорированы файлы по типа fileA.txt, fileB.txt
                        а вот к примеру file12.txt проигнорирован НЕ будет.
                [] - тоже самое, только можно добавить диапазон, но гит будет учитывать только файлы из него:
                    file[0-2].txt ~ file1.txt, file2.txt, либо символы - [abc, a-z]
                    
                --------------------------------------------------------------------------------------------------------
                
                / - игнорирует файл в корне проекта - /file.txt, а если / в конце то это относимо к папкам
                
                --------------------------------------------------------------------------------------------------------
                
                ** - может пропускать все папки и игнорировать даже если нет папок 
                
                --------------------------------------------------------------------------------------------------------
                
                !(исключения для избранного) - например мы хотим *.jpg, но мем с cat.jgp отставить 
                
                
                
                
                
                
                """

        );



    }
}



