package com.aberneko.learning.Git;

public class Git {
    static void main() {

// commit f9bd906861422db0f87130e710b64a669af02faf (HEAD -> main, origin/main, origin/HEAD)
        System.out.println(

                """
                f9bd906861422db0f87130e710b64a669af02faf --> хэш - идентификатор комита получается с помощью алгоритма
                SHA - 1. В то время как результат работы HashCode() - это целое число, хэширование в GIT - Символьная 
                строка состоящая из 40 символов. Все хэши и таблицу Git сохраняет в служебные файлы. Они находятся в 
                скрытой папке .git в репозитории проекта
                """

        /*
         commit f9bd906861422db0f87130e710b64a669af02faf (HEAD -> main, origin/main, origin/HEAD)              - ХЭШ
         Author: WorkAberneko <kurumi.06.10.t@gmail.com>                                             - АВТОР КОММИТА
         Date:   Wed Feb 11 15:48:02 2026 +0300                                                       - ДАТА КОММИТА
         Изменения структыры 2.0                                                                - ИНФОРМАЦИЯ КОММИТА
        */

        );



 // Сокращённый лог
        System.out.println(

                """
                Сокращённый лог вызывают командой 'git log' c флагом '--oneline' при этом в терминале,
                появляются только первые несколько символов хэша каждого комита и комментарии к ним.
                
                    `git log --graph --oneline --all` 
                        --graph: Рисует «дерево» из символов (*, |, /, \\) в левой части консоли.
                        --oneline: Сжимает каждый коммит до одной строки (хэш + заголовок), чтобы видеть всю историю сразу.
                        --all: Показывает абсолютно все ветки, даже те, на которых ты сейчас не находишься.
                        
                    Чтобы не вводить эту длинную команду каждый раз, давай создадим alias (сокращение). Введи это один раз:
                    
                        git config --global alias.lg "log --graph --oneline --all
                        
                            Теперь тебе достаточно написать просто git lg, и ты увидишь идеальную структуру своего проекта.
                            
                """

                /*   Если автоматический не произошёл выход, нажимаешь Q   */

        );



// HEAD
        System.out.println(

                """
                Один из служебных файлов папки .git который указывает на коммит, который сделан последним.
                (Применяется в качестве параметра вместо прописывания хэша).
                Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD.
                """

                /*

                $ pwd
                $ cd B/JavaAll
                $ cd .git/
                $ cd HEAD              <-- Наш служебный файл
                $ cat Head             <-- Просматриваем содержимое
                ref: refs/heads/main   <-- получаем ссылку на служебный фал
                $ cd refs/heads/main

                --> Получаем хэш последнего коммита

                */

        );



// Что бы избежать закомитить лишнее или же забыть добавить важный файл в коммит, нужно проверять СТАТУСЫ
// GIT STATUS
 // Статусы untracked/tracked, staged и modified
        System.out.println(

                """
                Ключевая задача отслеживать изменения в файлах
                
                    Каждый файл помечается статусом:
                
                        --> untracked (неотслеживаемый)
                              Git «видит», что такой файл существует, но не следит за изменениями в нём.
                
                        --> staged (подготовленный)
                              Состояние файла(staged иногда называют 'indexed' или `cached`) на этапе подготовки к
                              коммиту после команды '--git add'.
                
                        --> tracked (отслеживаемый)
                              Файлы который уже зафиксированный с помощью `--git commit` and `--git add`
                
                        --> modified (изменённый)
                              Файл который уже был под `--git commit` но в него опять внесли правки
                
                        `--git status` показывает только следующие состояние файлов
                         --> staged (Changes to be committed)
                         --> modified (Changes not staged for commit)
                         --> untracked (Untracked files)
                    
                            git status --ignored - отображает в выводе 
                """

        );



// Оформление сообщений к коммитам
        System.out.println(

                """
                `--git log --oneline` максимальная вместимость символов 72
                    Писать сообщение с инфинитивом в глаголе
                """

        );



// Как исправить коммит
        System.out.println(

                """
                `git commit --amend` - внести правки уже в созданный коммит
                
                    `--no-edit` - говорит гиту сохранить сообщение прошлого коммита
                
                        Так же стоить отметить что после выполнения данной команды старый коммит и новый смешиваются 
                        под новым номером хэша. То есть проще говоря создается новый коммит (объект) а старый удаляется
                
                            '-m " " - для изменения сообщения коммита (Хэш коммита тоже и изменится)
                    
                """
        );



// Как откатится назад если все сломалось
        System.out.println(

                """
                `--git restore --staged` <file> - убрать файл из добавленных(staged). <.> - убрать всё.
               
                `-git reset --hard <commit>` - откат(удаление) последнего коммита
                
                `--git restore file` - откатывает изменения файла если он находится в статусе modified + 
                                       (на этапе staged and tracked)
                                       
                """

        );



// git diff - Просматриваем изменения и сопоставляем коммиты
        System.out.println(

                """
                `git diff <log>` - позволяет просмотреть изменения в коммите
                    --- a/pro.txt - до изменения
                    +++ b/pro.txt - после изменения
                
                    красный (-) была удалена
                    зелёный (+) была добавлена
                
                В самом выводе @@ -1,2 +1,9 @@ 
                            
                            с `-` показывает что в старой версии файла этот кусок занимал 2 строки начиная с первой
                            с `+` показывает что в новой версии файла этот кусок занимает 9 строк но всё же начинается с первого файла 
                            
                с приставкой --staged просматриваю изменения на этапе подготовки к коммиту
                """

        );



// .gitignore
        System.out.println(

                """
                .gitignore - файлы которые мы хотим игнорировать перед выполнением команд `--git add or commit -m`
                Это обычный текстовый файл который добавляют в корень репозитория и тоже комитят
                
                В простейшем случае в него указывают все файлы по одному на строку, но лучше использовать -
                ШАБЛОН - способ указать сразу несколько файлов с однотипным названием
                
                --------------------------------------------------------------------------------------------------------
                
                # - комментарий - он не будет их учитывать
                
                --------------------------------------------------------------------------------------------------------
                
                * (Пример *.txt) - будет игнорировать все фалы с таким расширением
                        docs/*/tmp - будет игнорировать все файлы tmp пропуская 1 уровень папки docs 
                                Если поставить как правило одну лишь * - то git будет игнорировать все файлы
                                
                --------------------------------------------------------------------------------------------------------
                
                ? - если в file?.txt поставить знак вопроса, то будут проигнорированы файлы по типа fileA.txt, fileB.txt
                        а вот к примеру file12.txt проигнорирован НЕ будет.
                [] - тоже самое, только можно добавить диапазон, но гит будет учитывать только файлы из него:
                    file[0-2].txt ~ file1.txt, file2.txt, либо символы - [abc, a-z]
                    
                --------------------------------------------------------------------------------------------------------
                
                / - игнорирует файл в корне проекта - /file.txt, а если / в конце то это относимо к папкам
                
                --------------------------------------------------------------------------------------------------------
                
                ** - может пропускать все папки и игнорировать даже если нет папок 
                
                --------------------------------------------------------------------------------------------------------
                
                !(исключения для избранного) - например мы хотим *.jpg, но мем с cat.jgp отставить 
                
                """

        );

// ВЕТКИ
        System.out.println(

                """
                                    ВЕТКА - ЭТО ИЗОЛИРОВАННЫЙ ПОТОК РАЗРАБОТКИ ПРОЕКТА \\
                
                    Основная стабильная версия проекта хранится на ветке main или мастер. Она появляется автоматически 
                    при создании репозитория. Часто все новые ветки в репозитории отходят от `main`
                        
                        `git branch` - просмотреть ветки проекта. Выводятся ветки которые уже есть в проекте, `*` отмечено 
                        в какой ветке мы находимся в текущий момент времени 
                        
                              Для создания веток подойдет команда `git branch <Название ветки>`. Название ветки может 
                              состоять из разным символов, но ветки не предопределены иерархией как директории папок 
                              разделённые `/`.
                              
                              `-a` - просмотр и локальных и удалённых веток 
                                        
                              `git checkout` - переключится на другую ветку.
                              
                                    `-b <название ветки>` - создать ветку и сразу переключится на неё.
                                  
                              
                ========================================================================================================
                ////////////////////////////////////////////////////////////////////////////////////////////////////////
                ========================================================================================================              
                              
                                                       СРАВНЕНИЕ ВЕТОК  \\
                            
                    `git diff <Первая ветка> <Вторая ветка>`
                    
                 ========================================================================================================
                ////////////////////////////////////////////////////////////////////////////////////////////////////////
                ========================================================================================================   
                    
                                                ОБЪЕДИНЕНИЕ И УДАЛЕНИЕ ВЕТОК \\
                
                
                
                    Слияние веток - процесс добавление изменений с одной ветки в основную
                    
                        `git merge <name branch>` - слияние веток 
                        
                        ************************************************************************************************
                        yorui@aberneko MINGW64 /b/git-branches (main)
                        $ git merge feature/diff
                        Updating 2b32c55..cadb7c4                       // значит, что коммиты c 079cfbf по f30d441 были объединены.
                        Fast-forward                                    // режим слияния - линейная история коммитов - находится на одной памяти - одна ветка продолжает историю другой
                        README.md | 4 +++-
                        1 file changed, 3 insertions(+), 1 deletion(-)
                        ************************************************************************************************
                        
                        `--abort` откатить слияние веток при конфликте.
                        
                   `git branch -D <название_ветки>` - удаление ветки после объединения (Удалить без вопросов)
                        Удаление ветки происходит в основной ветки  
                            
                           `-d` - более безопасный способ удаления, так как с начало проверяет а полностью ли слиты ветки
                                (Удалит, но с начало проверит все ли коммиты перенеслись)
                                
                                ! Удаление локальной ветки через Git не удаляет ветку на GitHub ! 
                                
                ========================================================================================================
                ////////////////////////////////////////////////////////////////////////////////////////////////////////
                ========================================================================================================
                               
                                                РАБОТА С GIT HUB \\
                                               
                `git remote add origin git@github.com:%ИМЯ_АККАУНТА%/git-branches.git` - привязка удалённого репозитория к локальному 
                        В качестве параметров указываются имя удалённого репозитория (origin) и его URL.
                        
                        `git remote add origin` - создаёт origin как указатель на ссылку, что бы потом не пришлось писать полностью
                        
                         `git push -u origin main` (ветка которую мы кидаем на удалёнку):
                         
                                push - выталкивает изменения на сервер 
                                origin - ярлык которыый создан
                                main - имя ветки основой куда направляются изменения 
                                -u - привязывает мой локальную main к той что на удалёнке (для того что бы писать просто git push)
                   
                         ***********************************************************************************************
                         yorui@aberneko MINGW64 /b/git-branches (feature/merge-request)
                                 $ git push -u origin feature/merge-request
                                 Enumerating objects: 5, done.                                                          // пересчитал файлы и изменения которые я сделал
                                 Counting objects: 100% (5/5), done.                                                    // отправиль на север 
                                 Delta compression using up to 12 threads
                                 Compressing objects: 100% (2/2), done.
                                 Writing objects: 100% (3/3), 402 bytes | 402.00 KiB/s, done.
                                 Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
                                 remote:
                                 remote: Create a pull request for 'feature/merge-request' on GitHub by visiting:
                                 remote:      https://github.com/aberneko/git-branches/pull/new/feature/merge-request
                                 remote:
                                 To github.com:aberneko/git-branches.git
                                  * [new branch]      feature/merge-request -> feature/merge-request                    // создал ветку
                                 branch 'feature/merge-request' set up to track 'origin/feature/merge-request'.         // локальная ветка привязана к удалённой
                         ***********************************************************************************************
                                     
                                
                ========================================================================================================
                ////////////////////////////////////////////////////////////////////////////////////////////////////////
                ========================================================================================================
                
                                                    СОЗДАЁИ PULL REQUEST \\
                                                    
                                                    
                `pull request` - запрос на изменение (подтягивания)
                        ТЫ создал ветку, запушил ее на удалёнку, и теперь тебе нужно сделать запрос на вливание этой 
                        ветки в основную
                        
                ========================================================================================================
                ////////////////////////////////////////////////////////////////////////////////////////////////////////
                ========================================================================================================
                
                                                   ЗАБРАТЬ ИЗМЕНЕНИЯ С УДАЛЁНКИ \\
                                                   
                `git pull` - скачать изменения с удалённого репозитория
                
                        `git pull` и `git merge` выполнятся первыми перед пул реквестом, так как во время работы 
                                                 над проектом изменения могут далеко убежать впрерёд
                                                 
                        ************************************************************************************************
                        $ git checkout main # перешли в main
                                $ git pull                                                                              // подтянули новые изменения в main
                                $ git checkout my-branch                                                                // вернулись в рабочую ветку my-branch
                                $ git merge main                                                                        // влили main в новую ветку my-branch
                                $ git push -u origin my-branch                                                          // отправили ветку my-branch в удалённый репозиторий
                        ************************************************************************************************
                        
                """

        );



    }
}



